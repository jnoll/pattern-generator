{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}

-- automatically generated by BNF Converter
module PML where

import Utils

import Formal.PML.ErrM
import Formal.PML.AbsPML
import Formal.PML.Subtree (getSubtree, selectSubtree)
import Formal.PML.GraphOptions (defGraphOptions, GraphOptions(..))
import Formal.PML.Print (printPML) -- (printRequires, printProvides)
import Formal.PML.PrintBasic (findActionsPRIMs, findAgentsPRIMs, findRequiresPRIMs, findProvidesPRIMs, printAgentsPRIMs, printID, printSTRING)
import Formal.PML.GraphOptions (GraphType(..), GraphOptions(..), defGraphOptions)


import Control.Monad.Reader (Reader(..), ask, runReader)
import Data.List ((\\), find, intercalate, nub, sort)
import Data.Maybe (fromMaybe, fromJust, isJust)

import Text.Pandoc hiding (Str)
import Text.Pandoc.Definition hiding (Str)
import Text.Pandoc.Shared (trim) -- overkill, but Pandoc is included anyway

import System.Console.CmdArgs
import System.Environment (getArgs, getProgName)
import System.Exit (exitFailure, exitSuccess)
import System.IO (stdin, hGetContents)

gtmGraphOptions = defGraphOptions { gopt_prunedepth = 3
                                  , gopt_graphtype = Partitions
                                  , gopt_textwidth = 50
                                  , gopt_scriptwords = 0
                                  } 

modelGraphOptions = defGraphOptions { gopt_graphtype = Swimlanes
                                    , gopt_textwidth = 50
                                    , gopt_scriptwords = 1000
                                    } 

findFirstActs :: [PRIM] -> [PRIM]
findFirstActs [] = []
findFirstActs (p:_) = (findFirstActs') p -- ++ findFirstActs ps 


findLastActs :: [PRIM] -> [PRIM]
findLastActs [] = []
findLastActs (ps) = (findLastActs') $ last ps -- ++ findLastActs ps 

findFirstActs' :: PRIM -> [PRIM]
findFirstActs' (PrimSeq  _ ps) = findFirstActs' $ head ps
findFirstActs' (PrimSeln _ ps) = concat $ map findFirstActs'  ps
findFirstActs' (PrimBr   _ ps) = concat $ map findFirstActs'  ps
findFirstActs' (PrimIter _ ps) = findFirstActs' $ head ps
findFirstActs' (PrimTask _ ps) = findFirstActs' $ head ps
findFirstActs' a@(PrimAct  id optype spcs) = [a]

findLastActs' :: PRIM -> [PRIM]
findLastActs' (PrimSeq  _ ps) = findLastActs' $ last ps
findLastActs' (PrimSeln _ ps) = concat $ map findLastActs'  ps
findLastActs' (PrimBr   _ ps) = concat $ map findLastActs'  ps
findLastActs' (PrimIter _ ps) = findLastActs' $ last ps
findLastActs' (PrimTask _ ps) = findLastActs' $ last ps
findLastActs' a@(PrimAct  id optype spcs) = [a]


getAgents :: String -> String ->  [String]
getAgents pml subtree = 
    let t@(Process _ ps) = getSubtree subtree pml
    in nub $ printAgentsPRIMs ps

getInOutputs :: IOType -> String -> String -> [String]
getInOutputs typ pml subtree =
    let (Process _ ps) = getSubtree subtree pml
        es = if typ == Input then map (printExpr defaultPrintExpr {pe_exists = " available"}) $ findRequiresPRIMs $ findFirstActs ps
             else map (printExpr defaultPrintExpr {pe_exists = " created or updated"}) $ findProvidesPRIMs $ findLastActs ps
    in sort $ nub $ concat $ es


getAction :: [(String, String, String, [String])] -> String -> Maybe (String, String, String, [String])
getAction as a = find (\(nm, _, _, _) -> nm == a) as


getActions :: String -> String -> Maybe [String] -> [(String, String, String, [String])]
getActions pml subtree anames = 
    let (Process _ ps) = getSubtree subtree pml
        as = findActionsPRIMs ps
    in if isJust anames then map fromJust $ filter (\a -> maybe False (\_ -> True) a) $ map (getAction as) $ fromJust anames
       else as

-- Sort of equivalent to: pml-graphit --subtree subtree --actions "actions, color" --depth 2 pml
getPuml :: String -> String -> GraphOptions -> String
getPuml pml subtree opts = 
    let puml = printPML opts  $ getSubtree subtree pml
    --in "getPuml: " ++ subtree ++ " " ++ (show $ gopt_color opts)
    in head puml

-- A set of strings to customize resource output.
data PrintExpr = PrintExpr {
  pe_exists :: String
  , pe_or :: String
  , pe_eq :: String
  , pe_ne :: String 
  , pe_lt :: String 
  , pe_gt :: String 
  , pe_le :: String 
  , pe_ge :: String 
  , pe_veq :: String 
  , pe_vne :: String 
  , pe_not :: String
} deriving Show;

defaultPrintExpr = PrintExpr {
  pe_exists = " exists"
  , pe_or = " or "
  , pe_eq = " is "
  , pe_ne = " is not "
  , pe_lt = " is less than "
  , pe_gt = " is greater than "
  , pe_le = " is less than or equal to "
  , pe_ge = " is greater than or equal to "
  , pe_veq = " is equal to "
  , pe_vne = " is not equal to "
  , pe_not = " does not exist"
}

-- How to turn a resource specification into markdown.
printExpr :: PrintExpr -> EXPR -> [String]

printExpr pe (DisjExpr l r) = [(intercalate " " $ printExpr pe l) ++ (pe_or pe) ++ (intercalate " " $ printExpr pe r)] -- XXX what should happen: append ", or" to the last element of lhs.
printExpr pe (ConjExpr l r) = (printExpr pe l) ++ (printExpr pe r)
printExpr pe (Str s)        = [printSTRING s ++ (pe_exists pe)]
printExpr pe (RelEq l r)    = [printVal l ++ (pe_eq pe) ++ printVal r]
printExpr pe (RelNe l r)    = [printVal l ++ (pe_ne pe) ++ printVal r]
printExpr pe (RelLt l r)    = [printVal l ++ (pe_le pe) ++ printVal r]
printExpr pe (RelGt l r)    = [printVal l ++ (pe_gt pe) ++ printVal r]
printExpr pe (RelLe l r)    = [printVal l ++ (pe_le pe) ++ printVal r]
printExpr pe (RelGe l r)    = [printVal l ++ (pe_ge pe) ++ printVal r]
printExpr pe (RelVeq l r)   = [printVar l ++ (pe_veq pe) ++ printVar r]
printExpr pe (RelVne l r)   = [printVar l ++ (pe_vne pe) ++ printVar r]

printExpr pe (PrimVar v) = [printVar v ++ (pe_exists pe)]
printExpr pe (PrimAttr (Attr v a)) = [printVar v ++ " " ++ printID a] -- assumes attr is a past-tense verb
printExpr pe (PrimNot e) = (printExpr pe e) ++ [(pe_not pe)]

printVar :: VAREXPR -> String
printVar (VarId i) = printID i
printVar (VarPar i) = "printVar.VarPar: " ++ printID i
printVar (VarMore qual expr) = printVar expr  -- (qualifier) resource -> resource


printVal :: VALEXPR -> String
printVal (ValAttr a) = printAttr a
printVal (ValString s) = printSTRING s
printVal (ValNum n) = show n

printAttr :: ATTREXPR -> String
printAttr (Attr vexp i) = printVar vexp 
